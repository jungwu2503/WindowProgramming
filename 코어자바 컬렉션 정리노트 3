배열 리소스
List 인터페이스는 항목의 순서를 따지는 Ordered Collection
항목을 찾는데에는 두개의 프로토콜이 있음 
- 반복자를 통하는 방법과 get,set을 통한 임의 접근 방법
후자는 연결 리스트에서는 적합하지 않지만 배열에서는 유용함
컬렉션 라이브러리는 List 인터페이스를 구현한 ArrayList 클래스 제공
ArrayList는 Vector와 유사함, 동적으로 재할당되는 Object[] 배열을 캡슐화 함

Vector 대신 ArrayList를 사용하는 이유 : Vector 클래스의 모든 메서드들은 동기화 되어있음.
두개의 쓰레드에서 Vector 객체를 접근하는 것은 안전하다. 그러나 단일 스레드에서 벡터에 접근한다면 동기화로 인해 일정한 시간을 소비해야함.
동기화가 필요하지 않을경우에는 Vector대신 ArrayList

해쉬 셋
연결 리스트와 배열은 정렬하고자 하는 항목의 순서를 명시할 수 있게 해줌. 만약 특정 항목을 찾길 바라는데 그 위치를 기억하지 못한다면 맞는 항목을 찾을 때까지 모든 항목을 방문해야 함.
항목들의 순서를 고민할 필요가 없다면 보다 빠르게 항ㅁ고을 찾게 해주는 데이터 구조가 존재함. 객체들을 빠르게 찾는데 있어 잘 알려진 데이터 구조는 해쉬 테이블.
해쉬 테이블은 각 객체에 대해 해쉬 코드라 불리는 정수를 계산해냄.
해쉬 테이블은 연결 리스트의 배열. 각 리스트는 버켓이라 불림. 테이블에서 객체의 위치를 찾기위해 해당 객체의 해쉬코드를 계산해내고 이를 총 버켓수에서 모듈로 연산. 버켓에 항목 추가할 때
이미 채워져 있다면 해쉬충돌(hash collision).
해쉬 테이블의 성능을 조정하길 원한다면 초기 버켓수를 명시 가능. 
얼마나 많은 항목들을 저장할 것인지 알 필요x, 해쉬 테이블이 꽉 차면 재해쉬(rehash)할 필요가 있음. 테이블을 재해쉬하기 위해 보다 많은 버켓을 갖는 테이블을 생성하고 모든 항목들을
새로운 테이블 내에 삽입. 그리고 본래의 테이블을 버림.
자바에서 로드 팩터(load factor)는 해쉬 테이블이 재해쉬 될때를 결정함. 로드 팩터가 0.75일때(해쉬 테이블이 75% 이상 채워질때) 재해쉬.
해쉬 테이블은 몇몇 중요한 데이터 구조를 구현하기 위해 사용되어짐.
set은 중복없이 항목들을 컬렉션함. set의 add메서드는 먼저 추가할 객체를 찾고 아직 제공된 것이 아닐 경우만 추가.

해쉬 함수
문자열들을 해쉬 셋에 삽입가능. String 클래스는 해당 문자열에 대한 해쉬 코드를 계산해내는 hashCode 메소드를 가짐.
여러 방법으로 데이터 필드들의 해쉬 코드들을 섞는 것은 서로 다른 객체들을 위한 해쉬 코드가 넓게 분포되도록 함
x.equals(y)가 true이면 x.hashCode()는 y.hashCode()와 같은값.

object
boolean equals(Object obj) : 두 객체가 동일한지 비교.
int hashCode() : 해당 객체에 대한 해쉬 코드 반환. 해쉬 코드는 모든 양수 또는 음수가 될 수 있음. 동일한 객체들은 동일한 해쉬코드 반환.

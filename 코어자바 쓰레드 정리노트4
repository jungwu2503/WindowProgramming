프로그램에서 스레드를 사용하는 이유들 중 하나는 프로그램을 보다 민감하게 만드는 것. 
프로그램이 무엇인가 시간을 소비하는 작업을 필요로 할때 사용자 인터페이스를 블로킹하는 대신에 다른 작업 스레드를 생성.
스윙은 스레드에 안전하지 않음. 스윙 클래스들의 대다수 메서드들이 동기화 되지 않았기 때문. 만약 다중 쓰레드로부터 사용자 인터페이스 요소들을 조작하려 한다면 사용자 인터페이스는 붕괴될 것.
스윙 디자이너들은 여러 이유로 스윙을 쓰레드에 안전하게 만드는 노력을 않기로함
스윙이 느려지는것을 원치 않아서, 프로그래머 그들 자신의 사용자 인터페이스 컴포넌트를 추가할 수 있도록 하기 위해

스윙 프로그램에서 main메서드가 기본적으로 수행하는 것 
- 프레임 윈도우에 컴포넌트들의 레이아웃을 위한 생성자 호출
- 윈도우 상의 show나 setVisible메서드 호출

만일 액션이 시간을 많이 소비하면, 해당 작업을 수행하는 새로운 스레드를 생성. 만약
이벤트 디스패치 쓰레드에서 오랜 시간이 걸리면 응용프로그램은 다른 이벤트들에 반응을 할 수 없기 때문에 죽은것처럼 보임.
만약 액션이 입출력 상에 블록이 걸리면, 이 작업을 수행할 새로운 스레드를 생성.
만약 특정한 시간동안 대기하고 있을 필요가 있을때 이벤트 디스패치 쓰레드에서 잠들면 안됨. 대신 타이머 사용.
쓰레드에서 우리가 수행하는 작업은 사용자 인터페이스에 접촉할 수 없다. 쓰레드를 올리기전에 UI로부터 모든 정보를 읽고, 쓰레드 올린후 이벤트 디스패칭 스레드로부터 사용자 인터페이스 갱신.

단일스레드 규칙
소수의 스윙 메소드들은 쓰레드에 안전함. (API에 This method is thread safe. although most Swing method are not 이라고 표기)
-> ■ JTextComponent.setText / ■ JTextArea.insert / ■ JTextArea.append / ■ JTextArea.replaceRange
JComponent 클래스의 다음 메서드들은 모든 쓰레드로부터 호출 가능
-> ■ repaint / ■ revalidate
안전하게 모든 스레드에서 이벤트 리스너를 추가하고 제거가능. 리스너 모델들은 이벤트 디스패칭 스레드에서 호출.
컴포넌트들을 생성하고 이들의 속성을 설정하고 컨테이너에 추가할 수 있다. 단, 컴포넌트들이 실제화 되지 않아야한다. 컴포넌트들이 페인트나 벨리데이션 이벤트를 받는다면 실제화된다.
이것은 show, setVisible 또는 pack 메서드가 컴포넌트 상에서 호출되자마자 실제화 되거나 컨테이너에 컴포넌트들이 추가될 떄 실제화된다. 일단 컴포넌트들이 실제화되면 더이상 다른 스레드에서
이들을 조작할 수 없다. 
진행 바나 라벨 텍스트를 갱신하길 원할 때 우리의 쓰레드에서 이들의 값을 설정할수 없음.
이 문제를 풀기 위해, 모든 스레드 내에서 이벤트 큐에 임의의 액션들을 추가할 수 있게해주는 두개의 편리한 유틸리티 메서드가 있음.
한 쓰레드에서 진행상태를 알려주는 "x% complete"라는 라벨을 주기적으로 갱신하길 원할떄, 우리는 스레드로부터 label.setText호출불가. 그러나 이벤트 디스페칭 스레드에서
실행되는 EventQueue클래스의 invokeLater와 invokeAndWait 메서드를 사용가능. 스윙 코드를 Runnable 인터페이스를 구현한 클래스의 run메서드에 위치하게 하고, 해당 클래스의 객체 생성 후
이를 invokeLater나 invokeAndWait 정적 메서드에 전달.
invokeLater 메서드는 이벤트가 이벤트 큐에 도달했을때 즉시 반환. InvokeAndWait 메서드는 run메서드가 실제 실행될 때까지 대기. 진행 레벨을 갱신하는 상황에서 invokeLater가 더 적합.

공유자원에 대한 동기화 접근
unsynchBankTest는 수천번의 트렌젝션 후에 에러가 잠복함. 일정한 양의 돈이 분실되거나 자연발생함.
이 문제는 두개의 쓰레드들이 동시에 계정에 갱신을 시도했기 때문.
쓰레드가 비슷한 우선순위를 가진다면 오류가 발생할 기회가 덜함(절반의 쓰레드에게 나머지보다 높은 우선 순위를 제공할 때 오류의 확률 커짐) = 우선순위 높은 쓰레드가 수면에서 깨어났을떄 우선순위 낮은 쓰레드를 선점하기 때문.
대부분의 프로그래밍 환경들은 자원에 대한 접근시 인터럽트 되지 않도록 세마포어(Semaphore)와 임계영역(Critical Section) 기술을 강제함. 
synchronized를 통해 인터럽트 받지 말아야 할 메소드 지정가능.
쓰레드가 동기화 된 메소드를 호출할 때 객체는 락(locked)됨.
생성시 외에는 변화할 필요가 없는 인스턴스 변수들을 선언할 때 final로 선언하는 것은 매우 좋은 생각.(synchronized생략 가능)
몇몇 다른 스레드가 notify나 notifyAll 메서드를 호출하는것은 아주 중요. 한 쓰레드가 wait를 호출할떄 그 자체를 언블로킹할 방법은 없다. 만일 쓰레드 중의 어느 것도 대기중인 쓰레드의 언블록을 간섭하지 않는다면 결코 다시 수행되지 않는 데드락 상황 발생 시킬수 있음. 
다른 쓰레드들을 언블록으로 남겨놓고 프로그램을 중단시키는 쓰레드는 존재하지 않음.
notifyAll 메소드 사용후 모든 쓰레드 언블록 추천한다고 함
notifyAll 언제 호출? -> 기본 규칙은 객체의 상태가 기다리고 있는 쓰레드들에게 유리하게 변할 때마다 notifyAll 호출. (ex. 계정 잔액이 변할 때마다 대기중인 쓰레드는 잔액을 검사할 다른 기회 제공받음)

컬렉션 프레임웍
프레임웍은 향상된 기능을 구현하기 위한 토대를 구성하는 일련의 클래스들. 프레임웍은 유용한 기능과 정책 그리고 메커니즘을 
갖는 상위 클래스들을 포함. 프레임웍 사용자는 기본 메커니즘을 다시 작성할 필요없이 하위 클래스를 생성하여 기능 확장.
ex) 스윙은 사용자 인터페이스를 위한 프레임웍
자바 컬렉션 라이브러리는 컬렉션 클래스들을 위한 프레임웍 형성. 이 프레임웍은 많은 인터페이스와 컬렉션 구현자를 위한 추상화 
클래스를 정의. 그리고 반복자 프로토콜 같은 특정 메커니즘 서술. 프레임웍에 대해 자세히 알 필요없이 클래스들을 사용할 수 있지만,
다중 컬렉션 타입들에 대해 작동하는 보편적인 알고리즘을 구현할 필요가 있거나 새로운 컬렉션 타입을 추가하길 원한다면 프레임웍을 이해하는것이 도움.

이론적으로 List 인터페이스를 확장한 Array 인터페이스와 임의 접근 메서드의 선언을 분리한 것은 당연한 것. 만일 별도의 Array 인터페이스가 있다면 이들 알고리즘은
Array 전달인자를 사용하기위해 임의 접근을 요구함. 그러면 늦은 임의 접근을 제공하는 컬렉션에 알고리즘을 적용할 수 없게 됨. 컬렉션 프레임웍의 디자이너들은
별도의 인터페이스를 정의하지 않기로 결정. 그들은 라이브러리 내에 인터페이스 수를 최소화하길 원함. 자유롭게 임의 접근을 사용하는 알고리즘에 연결 리스트를 전달할 수 있음.

Set 인터페이스는 Collection 인터페이스와 동일. 그러나 메서드의 행동은 보다 밀접하게 정의됨. Set의 add메서드는 중복 거부. Set의 equals 메서드는 같은 항목들을
가지고 있는 두개의 Set이 동일한지 정의해야함. Set과 List에 대해 잘 정의된 동일성 개념이 있음. 두개의 Set이 같은 순서로 같은 항목을 포함하고 있다면 동일.
두개의 리스트는 같은 순서로 같은 항목을 포함하고 있다면 동일. 그러나 컬렉션을 위해서는 잘 정의된 동일성 개념이 존재하지 않음. 그러므로 Collection 참조상의 equals 메서드는 사용x

메서드의 서명이 같은 인터페이스를 분리하는 이유는? 개념적으로 모든 컬렉션이 Set이 아님. Set 인터페이스를 만든 것은 프로그래머들이 오직 수용하는 Set들의 메서드들을 작성할 수 있도록 함.
SortedSet과 SortedMap 인터페이스는 정렬을 위해 사용되는 비교객체 노출. 이들 인터페이스는 컨테이너들의 일부 뷰를 얻을 수 있는 메서드를 정의함.

뷰와 Wrapper
뷰를 사용하여 Collection이나 Map 인터페이스를 구현한 다른 객체들을 얻을 수 있음. 마치 새로운 셋을 생성하고 맵의 모든 키들로 이를 채우고 반환 하는 메서드처럼 보이는 
맵 클래스의 KeySet메서드를 갖는 객체의 예는 실제가 아니다. 대신 KeySet메서드는 Set인터페이스를 구현하고 오리지널 맵을 조작하는 메서드를 갖는 클래스의 객체를 반환함. 이 같은
컬렉션을 뷰라고 부름. 뷰를 구현하기 위해 정확히 무슨 클래스 라이브러리를 사용했는지 알 방법이 없으며 알 필요도 없음. 뷰 기술은 컬렉션 프레임웍 내에 많은 유용한 응용
프로그램을 가지고 있음. Vector 클래스의 메서드들이 동기화되어 있다는 것을 생각하면 이 메서드들은 벡터가 오직 단일 쓰레드에서 접근할 경우 불필요하게 느림. 이러한 이유때문에
Vector 대신 ArrayList 사용. 그러나 다중 쓰레드에서 컬렉션에 접근하면 동기화된 메서드가 아주 중요. 만일 한 쓰레드가, 다른 쓰레드가 항목들을 재해쉬 하는동안, 해쉬테이블에 추가하려고
한다면 많은 문제를 일으킴. 라이브러리 설계자들은 모든 데이터 구조에 대한 동기화 메서드들을 갖는 클래스들을 구현. 이들 메서드는 모든 인터페이스들을 위한 동기화된 뷰를 생성함.

다중 쓰레드로부터 한 컬렉션을 접근할 때의 한가지 주의할 점 - 컬렉션에서 읽어볼 수 있는 복수 개의 반복자를 갖거나 컬렉션을 변경하는 단일 쓰레드를 가질 수 있다. 
모든 반복자가 다른 쓰레드가 컬렉션을 변경할 때 동시에 작동하지 않게.
배타적 접근을 확실히 하는 한가지 방법은 반복자는 컨테이너를 lock하는 블록 내에 두는 것
